LK1
История операционных систем
ЭВМ 1го поколения - ОС пока не существует
1943 год - устройства для расчета баллистической таблицы
ЭНИАК - первый электронный дифференциальный анализатор(цифровой вычислитель)

Особенности:

использавание ламп(греются и горят)
возможность перепрограммирования
используются перфокарта
Недостатки:

для решения диф. уравнений ~ 1 млн перфокарт(перепрограммирование 2+ дня)
Архитектура фон Неймана
Особенности:

переход на двоичную систему (есть сигнал - 1; нет сигнала - 0)
уходят от перфокарт, память состоит из пронумерованных ячеек
Программа - последовательность команд, выполняются одна за другой.
image

ЭВМ 2го поколения
Плюсы:

нет тепла, нет перегорания -> надёжно
маленький размер, плотная компановка -> ЭВМ меньше
Недостатки:

сложная диагностика
дорогое производство
Появление алгоритмических языков (COBOL, ALGOL)
Появление компиляторов -> появление программистов
Пакетная обработка данных - задачи сменяются не вручную, а подаются на вход пачкой

второе поколение ЭВМ
пакетная обработка заданий, формализованный язык управления заданиями

ЭВМ 3-4го поколения
большие интегральные схемы 10 000 000 операций в секунду
3.
Плюсы интегральных схем:
- автоматизация производства, уменьшение стоимости
Многозадачность, принцип разделения времени
4.
- многозадачность
-Появление виртуальной памяти
появляются Apple и Unix
-принцип разделения времени
-база данных

Linux
в 80-ые годы появление протокола TCP/IP (Транспортная сеть-протокол, или протокол передачи данных) Этот протокол определил, что инфорпмация дробится на пакеты , у каждого из которых есть уникальный номер, что позволяет отслеживать их передачу.

Линус Торвальдс(1991)
-Утилиты: gcc, bash
-появление системных вызовов UNIX
-монолитное ядро

Функции операционной системы:
-обеспечение выполнения программы
-сколько памяти выдано
-обработка системных вызовов
-ввод и вывод данных
-организация доступа к устройствам посредством файловых систем
-обеспечение безопасности
-организация сетевого стека
-стандартизированный доступ к устройствам ввода-ввывода
-управление памятью системы(выделение, освобождение)

![image](https://user-images.githubusercontent.com/112687883/213100939-2fd5e7a1-22ac-4528-93a0-c47d8b8dde96.png)

Микроядерная архитектура

![image](https://user-images.githubusercontent.com/112687883/213101270-8ff5ca20-588b-44a9-8a27-7f60ce6b0627.png)

Совместимость ОС
Двоичная запуск экзе файла
На уровне исходных кодов передается файл с кодом

![image](https://user-images.githubusercontent.com/112687883/213102111-be3a32cf-0c6d-4976-ad3d-966898df2b86.png)


Особенности
в Unix все есть файл
(клавиатура, флэшка)

Типы файлов
1) Символьные устройства(клавиатура или любое устройство ввода)
2) Блочные устройства(дисковвод, флэшки, диски)
3) Каталоги(папки, директории)
4) Ссылки(ярлык)
Устройства связи
5) Именованные каналы(то, по чему идет связь)
6) Сокеты(узлы связи)

https://user-images.githubusercontent.com/112687883/215970735-51a92768-f1c4-4273-9a73-ec8d67fdb62f.png



защита 1 задания
ls (позволяет посмотреть, какие пап вам доступны)умолчанию
cd 'Рабочий стол' (позволяет перейти в папку, где лежит Ваш код),
gcc Hello.c -o test (компилирует вашу программу в файл с именем test (имя можно менять). /test (запуск кода).

GCC - GNU Compiler Collection - набор компиляторов и сопутствующих утилит, GCC входит в состав любого дистрибутива Linux и, как правило, устанавливается по умолчанию. 
a.out - имя обозначало assembler output



защита 2 задания 
1. что такое $?
это ввод команды от непривилеригорованного пользователя
команда: порядок данных, которые мы ищем (в нашем случае)

2. что такое inot?
это iD

3. что такое echo
как print вывод информации

4. что делают каналы?



5. в чем разница каналов и сокетов
каналы это процессы
а сокеты между процессами

ЛК4
Потоки ввода, ввывода:

STDIN(0)-стандартный ввод, файл из которого осуществляется чтение

STDOUT(1)-стандартный вывод,файл в который осуществляется запись

STDERR(2)-стандартный поток ошибок,файл в который осуществляется запись сообщений об ошибках

перенаправление ввода command<filename
                                       $cat<in_example_1
                                       $./input2.sh<in_example_1&
command>filename-rewrite 

command>>filename-append

2>/dev/null-заглушить STDERR

Процессы и потоки

Процесс- это набор ресурсов задачи во время ее выполнения:

память,открытые файловые дескрипторы,контекст выполнения,обработчики сигналов,как минимум один поток,pid.

Потоки имеют общую виртуальную память
![image](https://user-images.githubusercontent.com/97913101/217463528-2a542ee2-a12e-4b0e-80d2-84e1dd1a3d71.png)
![image](https://user-images.githubusercontent.com/97913101/217463614-77199431-5df1-418b-a191-2810b2cba61f.png)
![image](https://user-images.githubusercontent.com/97913101/217464165-6d1bed1c-b578-47fe-9ced-ba37b0970387.png)
![image](https://user-images.githubusercontent.com/97913101/217464282-4fc0acf4-0922-4525-ba75-a5f9f6ff1a97.png)
![image](https://user-images.githubusercontent.com/97913101/217464430-51d25537-4bd2-4df5-aa58-e63a835aa843.png)
![image](https://user-images.githubusercontent.com/97913101/217464751-3166bb10-9f3f-46ea-a26f-3b4496bc0229.png)
Жизненный цикл процесса
![image](https://user-images.githubusercontent.com/97913101/217466133-deac82ce-741a-44fb-baf7-01dca5010225.png)

Появление процесса в системе 
unit-создание процесса
fork()-коппирование процесса
есть дочерний и родительский процесс,дочерний процесс полная копия родительского но в первом получает управление,а его pid приписывается родительскому процессу
совместное адресное пространство copy-on-write
![image](https://user-images.githubusercontent.com/97913101/217467512-ff8cced2-42b9-4da1-9f7e-57b2d1e7bf32.png)
Смерть процесса:
exit(kill) или сигнал завершения 
По завершении, дочерний процесс переходит в состояние зомби
$ хранит код завершения последней команды



